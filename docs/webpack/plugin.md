plugin 用来做 loader 做不了的其它事，是 webpack 的重点。自己写一个 plugin [官方文档](https://webpack.docschina.org/contribute/writing-a-plugin/)



#### plugin 的构成

* 是一个构造函数或者 class
* 在原型上有一个 `apply` 方法，`apply`方法接收一个`compiler`参数

```javascript
// plugin1.js
const pluginName = 'HelloWorldPlugin '
class HelloWorldPlugin {
  apply(compiler) {
    compiler.hooks.run.tap(pluginName, (compilation) => {
      console.log('webpack 构建正在启动！')
    })
  }
}

module.exports = HelloWorldPlugin
```

apply 方法会在安装插件的时候被 webpack compiler 调用，并被传入一个compiler的参数。compiler是 webpack compiler 的引用，可以用它操作构建过程

[compiler的钩子](https://webpack.docschina.org/api/compiler-hooks/)

调用compiler.hooks 的钩子可以用 `tap tapAsync tapPromise` 3种形式。其中 Sync 类型的只能用 tap，AsyncParallel 和 AsyncSeries 可以用 `tap tapAsync tapPromise`[官方文档](https://github.com/webpack/tapable#hook-types)

#### Plugin的参数校验

一个plugin如果有入参，应该做参数校验。以下使用了 schema-util 提供的 validate 函数做参数校验，和 loader 的校验方式一样

```javascript
const pluginName = 'HelloWorldPlugin '
const { validate } = require('schema-utils')
const schema = require('./schema.json')
class HelloWorldPlugin {
  constructor(option = {}) {
    validate(schema, option, {
      name: 'Hello World Plugin',
    })
  }
  apply(compiler) {
    compiler.hooks.run.tap(pluginName, (compilation) => {
      console.log('webpack 构建正在启动！')
    })
  }
}

module.exports = HelloWorldPlugin

```

```json
// schema.json
{
  "type": "object",
  "properties": {
    "test": {
      "type": "string"
    }
  }
}

```

#### 实现一个将文件名列表输出到md文件的plugin

```javascript
class FileListPlugin {
  static defaultOptions = {
    outputFile: 'assets.md',
  }

  constructor(options = {}) {
  	// 合并选项，传入的 options 会覆盖默认的 defaultOptions
    this.options = { ...FileListPlugin.defaultOptions, ...options }
  }

  apply(compiler) {
    // 获取类名，作为 pluginName
    const pluginName = FileListPlugin.name

    // 从 compiler 中获取 webpack 可以保证版本的正确
    const { webpack } = compiler

    // Compilation object gives us reference to some useful constants.
    const { Compilation } = webpack

    // RawSource is one of the "sources" classes that should be used
    // to represent asset sources in compilation.
    const { RawSource } = webpack.sources

    // Tapping to the "thisCompilation" hook in order to further tap
    // to the compilation process on an earlier stage.
    compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {
      // Tapping to the assets processing pipeline on a specific stage.
      compilation.hooks.processAssets.tap(
        {
          name: pluginName,

          // Using one of the later asset processing stages to ensure
          // that all assets were already added to the compilation by other plugins.
          stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
        },
        (assets) => {
          // "assets" is an object that contains all assets
          // in the compilation, the keys of the object are pathnames of the assets
          // and the values are file sources.

          // Iterating over all the assets and
          // generating content for our Markdown file.
          const content =
            '# In this build:\n\n' +
            Object.keys(assets)
              .map((filename) => `- ${filename}`)
              .join('\n')

          // Adding new asset to the compilation, so it would be automatically
          // generated by the webpack in the output directory.
          compilation.emitAsset(this.options.outputFile, new RawSource(content))
        }
      )
    })
  }
}

module.exports = { FileListPlugin }

```

